<h4>What This Code Does</h4>
<p>
    <em>Function Currying</em> is the creation of <tt>n</tt> functions with a single argument from a single function with <tt>n</tt> arguments. Calling a curried function with an argument is like partially applying that argument. <em>Partial Application</em> and <em>Currying</em> are very similar, however <em>Currying</em> a function is done <em>without</em> providing any argument to the original function.
</p>
<p>
	We take a binary function invoker <code>biOp</code> with three arguments and create a new curried function by using a utility function. By calling the curried function in turn with the separate arguments of the original function we receive more and more specialised (and still curried) functions: First a binary sum function <code>plus</code> and last a function which just adds <tt>5.5</tt>.
</p>
<h4>What's the Same</h4>
<p>
    Both <strong class="text-bold">the Javascript</strong> and <strong class="text-bold">
    the C++</strong> solutions make use of 3rd party libraries (<a href="https://ramdajs.com">Ramda</a> and <a href="https://github.com/boostorg/hof">HOF</a> respectively) to create a curried function from <code>biOp</code>.
</p>
<h4>What's Different</h4>
<p>
    Using <a href="{{base_url}}/versus/js-lambdas">Lambdas</a> to define the original functions in C++, it looks very similar; Just add <pre>auto</pre> before every variable.
</p>