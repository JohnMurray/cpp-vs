<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">
<link rel="stylesheet" href="//cpp-vs.herokuapp.com/style/app.css">

    <title></title>
  </head>

  <body>
    <div class="page">

      <!-- Title & Navigation -->
      <div class="title-nav">
    <div class="logo">
        <img src="//cpp-vs.herokuapp.com/assets/logo.png" height="80" />
    </div>
    
    <div class="secondary-nav">
        <a class="primary-nav-link" href="//cpp-vs.herokuapp.com/about">About</a>
        <a class="primary-nav-link" href="https://www.twitter.com/johnmurray_io">Feedback</a>
    </div>

    <div class="navigation">
        <a class="primary-nav-link" href="//cpp-vs.herokuapp.com/">Versus</a>
    </div>
</div>

      <!--Content -->
      <div class="content">
        
<!-- 
    Just a placeholder, if you want to see more about how the versus
    code is templated, go look at the versus* files in the includes
    directory.
-->
<div class="code-vs-title"><h3>Higher Order Functions</h3></div>
<div class='code-vs-container'>
  <div class='code-left'>
    <div class="title"><h2>Cpp</h2></div>
    <pre><code class="language-cpp line-numbers">#include &lt;functional&gt;

template&lt;typename T&gt;
T sum(T a, T b) {
    return a + b;
}

template&lt;typename T, typename U&gt;
std::function&lt;U (T)&gt; collect(std::function&lt;U (U, U)&gt; fn, U init) {
    return [fn, init](T list) -&gt; U {
        U out = init;
        for (auto const &l: list) {
            out = fn(out, l);
        }
        return out;
    };
}

int main() {
    auto sumListInt = collect&lt;std::vector&lt;int&gt;, int&gt;(sum&lt;int&gt;, 0);
    auto multListInt = collect&lt;std::vector&lt;int&gt;, int&gt;([](int a, int b) -&gt; int {
        return a * b;
    }, 1);

    sumListInt(std::vector&lt;int&gt; {{1, 2, 3, 4}});
    // returns 10

    multListInt(std::vector&lt;int&gt; {{1, 2, 3, 4}});
    // returns 24
}</code></pre>
  </div>
  <div class='code-right'>
    <div class="title"><h2>JavaScript</h2></div>
    <pre><code class="language-javascript line-numbers">function sum(a, b) {
    return a + b;
}

function collect(fn, init) {
    return function(list) {
        let out = init;
        for (var i = 0; i &lt; list.length; i++) {
            out = fn(list[i], out);
        }
        return out;
    }
}

// compose 2 functions to create a new function
const sumList = collect(sum, 0);

// compose with a lambda to create a new function
const multList = collect((a, b) =&gt; a * b, 1);

sumList([1, 2, 3, 4])
// returns 10

multList([1, 2, 3, 4])
// returns 24</code></pre>
  </div>
</div>

<div class="code-description blurb">
  <h4>What This Code Does</h4>
<p>
    The goal of the above code is to combine functions together in order to
    create new functions. The composability of functions to generate new functions
    is a form of code-reuse and application of
    <span title="Don't Repeat Yourself" class="tool-tip">DRY</span> typically found
    in more functional or function-oriented languages. Our specific goal is to combine
    <code>collect</code>, which iterates over collection of items, with a function that
    works on single-elements, to create a new function that works over a collection of
    elements, to calculate an aggregate value.
</p>

<h4>What's the Same</h4>
<p>
    The structure of both solutions is identical. While both are idiomatic, both are also
    very raw. <strong class="text-bold">JavaScript</strong> has many libraries to help
    with this, such as <a href="https://lodash.com/">Lodash</a>. Similarly, C++ has
    <a href="https://github.com/boostorg/hof">Boost HOF</a> which contains utilities specifically for
    <span title="Higher Order Functions" class="tool-tip">HOF</span> programming in C++.
</p>

<h4>What's Different</h4>
<p>
    The differences mostly lie in type declarations and syntax. While the structure is
    the same, C++ must define all of the parameter and return types. Additionally, C++
    must make use of "generics" in order to account for different numeric types, such as
    <code>int</code>, <code>float</code>, <code>double</code>, etc. This is done with
    what is called C++ templates. Templates are expanded at compile-time into concrete
    implementations.
</p>
<pre class="language-cpp line-numbers"><code>// When used in code, a version is compiled to match the usage.
template&lt;typename T&gt;
sum(T a, T b) {
    return a + b;
}

void main() {
    sum&lt;int&gt;(1, 2);
    sum&lt;double&gt;(1.0, 2.0);
    // this causes 2 specialized versions to be compiled
}
</code></pre>
<p>
    In Javascript, all checking is done at runtime. That is to say, if we were to sum or multiply
    two types that were not compatible (e.g <code>4 * {some: "object"}</code>)), we would not know
    until the program ran. With C++, we will know at compile time when the templates are expanded
    into concrete functions. At that point we will know if the types can be added, multiplied, etc.
    Of course, most modern IDEs will give you some advanced notice as well. :-)
</p>
<p>
    The second noticeable difference is the lambda syntax and the type is represented.
    <code>std::function</code> is used to represent the return and parameter types like so:
</p>
<pre class="language-cpp"><code>std::function&lt;ReturnType (Arg1Type, Arg2Type, Arg3Type)&gt;
</code></pre>
<p>
    The lambda itself has 4 parts. The capture, the parameters, the return type, and the body.
</p>
<pre class="language-cpp"><code>int capture = 5;
    
auto lambda = [capture](int param1, int param2) -> int {
    return param1 + param2 + capture;
}
</code></pre>
<p>
    The <code>[capture]</code> part is a list of variables we'd like to "capture" in our lambda.
    These are things in our local scope we'd like to make available to our lambda. The parameters
    are pretty self-explanatory and what comes after the <code>-&gt</code>, but before the
    <code>{</code> is the return type. And, of course, what's in the curly-braces in the function
    body.
</p>
<p>
    Note the use of <code>auto</code> here is just a short-hand to avoid writing the full type of
    the lambda using <code>std::function</code>.
</p>
</div><div class="code-vs-title"><h3>Partial Application</h3></div>
<div class='code-vs-container'>
  <div class='code-left'>
    <div class="title"><h2>Cpp</h2></div>
    <pre><code class="language-cpp line-numbers">#include &lt;boost/hof.hpp&gt;
#include &lt;functional&gt;

template&lt;typename T&gt;
T sum(T a, T b) {
    return a + b;
}

int main() {
    std::function&lt;int(int)&gt; addFive = boost::hof::partial(
            BOOST_HOF_LIFT(sum&lt;int&gt;)
        )(5);

    addFive(10);
    // returns 15
}</code></pre>
  </div>
  <div class='code-right'>
    <div class="title"><h2>JavaScript</h2></div>
    <pre><code class="language-javascript line-numbers">const _ = require('lodash');

function sum(a, b) {
    return a + b;
}

const addFive = _.partial(sum, 5);

addFive(10);
// returns 15</code></pre>
  </div>
</div>

<div class="code-description blurb">
  <h4>What This Code Does</h4>
<p>
    <em>Partial application</em> is the ability to create a new function
    by only partially applying parameters to the original function.
</p>
<p>
    In the above code we create a new function from <code>sum(a, b)</code> by
    applying <code>5</code> as the first parameter. This new function
    <code>addFive</code> is the same as calling <code>sum(a, b)</code> where
    <code>a</code> is always <code>5</code>.
</p>
<h4>What's the Same</h4>
<p>
    Both <strong class="text-bold">the Javascript</strong> and <strong class="text-bold">
    the C++</strong> solutions make use of 3rd party libraries and both create a new
    function by passing the <code>sum</code> and the value <code>5</code> into the 3rd
    party's <code>partial</code> function.
</p>
<h4>What's Different</h4>
<p>
    Again, the main differences here are the types (which we understand now) and the libraries
    used. You may note one small difference that an additional utility is used in the C++ code
    that is not present in the JavaScript version, <code>BOOST_HOF_LIFT</code>. This is a simple
    utility that allows us to use <code>partial</code> on templated functions.
</p>
</div>

      </div>
    </div>

    <!-- footer -->
<div class="footer">
    <i>by <a href="#">@johnmurray_io</a></i>
</div>
    <!-- Fork Me! -->
<a href="https://github.com/JohnMurray/cpp-vs">
    <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub">
</a>
    <!-- Boostrap JS -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js" integrity="sha384-cs/chFZiN24E4KMATLdqdvsezGxaGsi4hLGOzlXwp5UZB1LY//20VyM2taTB4QvJ" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js" integrity="sha384-uefMccjFJAIv6A+rW+L4AHf99KvxDjWSu1z9VI8SKNVmz4sk7buKt/6v9KI65qnm" crossorigin="anonymous"></script>

<!-- Prism JS (code highlighting) -->
<script src="//cpp-vs.herokuapp.com/js/prism.js"></script>

  </body>
</html>
